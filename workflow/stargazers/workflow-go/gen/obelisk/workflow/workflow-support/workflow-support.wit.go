// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package workflowsupport represents the imported interface "obelisk:workflow/workflow-support@3.0.0".
package workflowsupport

import (
	"github.com/obeli-sk/demo-stargazers/workflow-go/gen/obelisk/types/execution"
	"github.com/obeli-sk/demo-stargazers/workflow-go/gen/obelisk/types/time"
	"go.bytecodealliance.org/cm"
)

// ScheduleAt represents the type alias "obelisk:workflow/workflow-support@3.0.0#schedule-at".
//
// See [time.ScheduleAt] for more information.
type ScheduleAt = time.ScheduleAt

// DateTime represents the type alias "obelisk:workflow/workflow-support@3.0.0#datetime".
//
// See [time.DateTime] for more information.
type DateTime = time.DateTime

// JoinSet represents the imported type alias "obelisk:workflow/workflow-support@3.0.0#join-set".
//
// See [execution.JoinSet] for more information.
type JoinSet = execution.JoinSet

// DelayID represents the type alias "obelisk:workflow/workflow-support@3.0.0#delay-id".
//
// See [execution.DelayID] for more information.
type DelayID = execution.DelayID

// ExecutionID represents the type alias "obelisk:workflow/workflow-support@3.0.0#execution-id".
//
// See [execution.ExecutionID] for more information.
type ExecutionID = execution.ExecutionID

// ResponseID represents the type alias "obelisk:workflow/workflow-support@3.0.0#response-id".
//
// See [execution.ResponseID] for more information.
type ResponseID = execution.ResponseID

// ClosingStrategy represents the enum "obelisk:workflow/workflow-support@3.0.0#closing-strategy".
//
// The closing strategy of a join set. Join sets are closed when execution finishes.
//
//	enum closing-strategy {
//		complete
//	}
type ClosingStrategy uint8

const (
	// All submitted child execution requests that were not awaited by the workflow are
	// awaited during join set close.
	// Delay requests are not awaited.
	ClosingStrategyComplete ClosingStrategy = iota
)

var _ClosingStrategyStrings = [1]string{
	"complete",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e ClosingStrategy) String() string {
	return _ClosingStrategyStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e ClosingStrategy) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *ClosingStrategy) UnmarshalText(text []byte) error {
	return _ClosingStrategyUnmarshalCase(e, text)
}

var _ClosingStrategyUnmarshalCase = cm.CaseUnmarshaler[ClosingStrategy](_ClosingStrategyStrings[:])

// JoinSetCreateError represents the variant "obelisk:workflow/workflow-support@3.0.0#join-set-create-error".
//
// Error variants that may occur on named join set creation.
//
//	variant join-set-create-error {
//		conflict,
//		invalid-name(string),
//	}
type JoinSetCreateError cm.Variant[uint8, string, string]

// JoinSetCreateErrorConflict returns a [JoinSetCreateError] of case "conflict".
func JoinSetCreateErrorConflict() JoinSetCreateError {
	var data struct{}
	return cm.New[JoinSetCreateError](0, data)
}

// Conflict returns true if [JoinSetCreateError] represents the variant case "conflict".
func (self *JoinSetCreateError) Conflict() bool {
	return self.Tag() == 0
}

// JoinSetCreateErrorInvalidName returns a [JoinSetCreateError] of case "invalid-name".
func JoinSetCreateErrorInvalidName(data string) JoinSetCreateError {
	return cm.New[JoinSetCreateError](1, data)
}

// InvalidName returns a non-nil *[string] if [JoinSetCreateError] represents the variant case "invalid-name".
func (self *JoinSetCreateError) InvalidName() *string {
	return cm.Case[string](self, 1)
}

var _JoinSetCreateErrorStrings = [2]string{
	"conflict",
	"invalid-name",
}

// String implements [fmt.Stringer], returning the variant case name of v.
func (v JoinSetCreateError) String() string {
	return _JoinSetCreateErrorStrings[v.Tag()]
}

// JoinNextError represents the variant "obelisk:workflow/workflow-support@3.0.0#join-next-error".
//
// Error variants that may occur when calling `join-next` function.
//
//	variant join-next-error {
//		all-processed,
//	}
type JoinNextError uint8

const (
	// All submitted requests and their responses were already processed.
	JoinNextErrorAllProcessed JoinNextError = iota
)

var _JoinNextErrorStrings = [1]string{
	"all-processed",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e JoinNextError) String() string {
	return _JoinNextErrorStrings[e]
}

// MarshalText implements [encoding.TextMarshaler].
func (e JoinNextError) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
// case. Returns an error if the supplied text is not one of the enum cases.
func (e *JoinNextError) UnmarshalText(text []byte) error {
	return _JoinNextErrorUnmarshalCase(e, text)
}

var _JoinNextErrorUnmarshalCase = cm.CaseUnmarshaler[JoinNextError](_JoinNextErrorStrings[:])

// RandomU64 represents the imported function "random-u64".
//
// Returns a random u64 in the range [min, max).
//
//	random-u64: func(min: u64, max-exclusive: u64) -> u64
//
//go:nosplit
func RandomU64(min_ uint64, maxExclusive uint64) (result uint64) {
	min0 := (uint64)(min_)
	maxExclusive0 := (uint64)(maxExclusive)
	result0 := wasmimport_RandomU64((uint64)(min0), (uint64)(maxExclusive0))
	result = (uint64)((uint64)(result0))
	return
}

// RandomU64Inclusive represents the imported function "random-u64-inclusive".
//
// Returns a random u64 in the range [min, max].
//
//	random-u64-inclusive: func(min: u64, max-inclusive: u64) -> u64
//
//go:nosplit
func RandomU64Inclusive(min_ uint64, maxInclusive uint64) (result uint64) {
	min0 := (uint64)(min_)
	maxInclusive0 := (uint64)(maxInclusive)
	result0 := wasmimport_RandomU64Inclusive((uint64)(min0), (uint64)(maxInclusive0))
	result = (uint64)((uint64)(result0))
	return
}

// RandomString represents the imported function "random-string".
//
// Returns a random string with a length in the range [min_length, max_length).
// The string consists only of alphanumeric characters (lowercase and uppercase letters,
// digits).
//
//	random-string: func(min-length: u16, max-length-exclusive: u16) -> string
//
//go:nosplit
func RandomString(minLength uint16, maxLengthExclusive uint16) (result string) {
	minLength0 := (uint32)(minLength)
	maxLengthExclusive0 := (uint32)(maxLengthExclusive)
	wasmimport_RandomString((uint32)(minLength0), (uint32)(maxLengthExclusive0), &result)
	return
}

// Sleep represents the imported function "sleep".
//
// Block execution for given time, return `schedule-at` resolved to time when the
// execution is scheduled.
//
//	sleep: func(schedule-at: schedule-at) -> datetime
//
//go:nosplit
func Sleep(scheduleAt ScheduleAt) (result DateTime) {
	scheduleAt0, scheduleAt1, scheduleAt2 := lower_ScheduleAt(scheduleAt)
	wasmimport_Sleep((uint32)(scheduleAt0), (uint64)(scheduleAt1), (uint64)(scheduleAt2), &result)
	return
}

// SubmitDelay represents the imported function "submit-delay".
//
// Submit a delay request to the join set. The delay can be later polled using `join-next`.
//
//	submit-delay: func(join-set: borrow<join-set>, timeout: schedule-at) -> delay-id
//
//go:nosplit
func SubmitDelay(joinSet JoinSet, timeout ScheduleAt) (result DelayID) {
	joinSet0 := cm.Reinterpret[uint32](joinSet)
	timeout0, timeout1, timeout2 := lower_ScheduleAt(timeout)
	wasmimport_SubmitDelay((uint32)(joinSet0), (uint32)(timeout0), (uint64)(timeout1), (uint64)(timeout2), &result)
	return
}

// NewJoinSetNamed represents the imported function "new-join-set-named".
//
// Create a new completing join set.
//
//	new-join-set-named: func(name: string, closing-strategy: closing-strategy) -> result<join-set,
//	join-set-create-error>
//
//go:nosplit
func NewJoinSetNamed(name string, closingStrategy ClosingStrategy) (result cm.Result[JoinSetCreateErrorShape, JoinSet, JoinSetCreateError]) {
	name0, name1 := cm.LowerString(name)
	closingStrategy0 := (uint32)(closingStrategy)
	wasmimport_NewJoinSetNamed((*uint8)(name0), (uint32)(name1), (uint32)(closingStrategy0), &result)
	return
}

// NewJoinSetGenerated represents the imported function "new-join-set-generated".
//
// Create a new completing join set with a generated name.
//
//	new-join-set-generated: func(closing-strategy: closing-strategy) -> join-set
//
//go:nosplit
func NewJoinSetGenerated(closingStrategy ClosingStrategy) (result JoinSet) {
	closingStrategy0 := (uint32)(closingStrategy)
	result0 := wasmimport_NewJoinSetGenerated((uint32)(closingStrategy0))
	result = cm.Reinterpret[JoinSet]((uint32)(result0))
	return
}

// Close represents the imported function "close".
//
// Explicitly close join set. All executions that were submitted and not awaited,
// in other words executions with unprocessed responses, will be either
// awaited or cancelled based on `closing-strategy`.
// Extension function `-get` can be used to lookup the execution result.
//
//	close: func(join-set: join-set)
//
//go:nosplit
func Close(joinSet JoinSet) {
	joinSet0 := cm.Reinterpret[uint32](joinSet)
	wasmimport_Close((uint32)(joinSet0))
	return
}

// JoinNext represents the imported function "join-next".
//
// Block the workflow execution until next response associated with the join set arrives.
// The response is marked as processed.
// Child execution result can be obtained using `-get` extension function using the
// returned execution ID.
// Return `join-next-error::all-processed` if the join set has all requests matched
// with responses.
//
//	join-next: func(join-set: borrow<join-set>) -> result<response-id, join-next-error>
//
//go:nosplit
func JoinNext(joinSet JoinSet) (result cm.Result[ResponseIDShape, ResponseID, JoinNextError]) {
	joinSet0 := cm.Reinterpret[uint32](joinSet)
	wasmimport_JoinNext((uint32)(joinSet0), &result)
	return
}
